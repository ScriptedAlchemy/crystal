/**
 * Web server for running Crystal backend without Electron
 * Used for browser-based testing with Playwright
 */

import express from 'express';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Mock electron app for web mode
const mockElectronApp = {
  getPath: (name: string) => {
    const homeDir = process.env.HOME || process.env.USERPROFILE || '/tmp';
    switch (name) {
      case 'userData':
        return path.join(homeDir, '.crystal');
      case 'home':
        return homeDir;
      default:
        return homeDir;
    }
  },
  getName: () => 'Crystal Web Test',
  getVersion: () => '0.2.0',
  isPackaged: false,
  quit: () => process.exit(0),
};

// Replace electron imports with mocks
require.cache[require.resolve('electron')] = {
  exports: {
    app: mockElectronApp,
    ipcMain: {
      handle: () => {},
      on: () => {},
      removeHandler: () => {},
    },
    dialog: {
      showOpenDialog: () => Promise.resolve({ canceled: true }),
      showSaveDialog: () => Promise.resolve({ canceled: true }),
    },
    shell: {
      openExternal: () => Promise.resolve(),
    },
    BrowserWindow: class {
      static getAllWindows() { return []; }
      static fromWebContents() { return null; }
    },
  },
  id: require.resolve('electron'),
  filename: require.resolve('electron'),
  loaded: true,
  parent: null,
  children: [],
  paths: [],
};

import { TaskQueue } from './services/taskQueue';
import { SessionManager } from './services/sessionManager';
import { ConfigManager } from './services/configManager';
import { WorktreeManager } from './services/worktreeManager';
import { WorktreeNameGenerator } from './services/worktreeNameGenerator';
import { GitDiffManager } from './services/gitDiffManager';
import { GitStatusManager } from './services/gitStatusManager';
import { ExecutionTracker } from './services/executionTracker';
import { DatabaseService } from './database/database';
import { RunCommandManager } from './services/runCommandManager';
import { PermissionIpcServer } from './services/permissionIpcServer';
import { VersionChecker } from './services/versionChecker';
import { StravuAuthManager } from './services/stravuAuthManager';
import { StravuNotebookService } from './services/stravuNotebookService';
import { ClaudeCodeManager } from './services/claudeCodeManager';
import { Logger } from './utils/logger';

export async function startWebServer(port = process.env.PORT ? Number(process.env.PORT) : 3030) {
  const app = express();
  
  // Middleware
  app.use(cors({
    origin: ['http://localhost:4521', 'http://localhost:3000', 'http://127.0.0.1:4521'],
    credentials: true,
  }));
  app.use(express.json({ limit: '50mb' }));
  app.use(express.urlencoded({ extended: true, limit: '50mb' }));

  // Initialize services
  const logger = new Logger();
  const databaseService = new DatabaseService();
  const configManager = new ConfigManager();
  const worktreeManager = new WorktreeManager();
  const worktreeNameGenerator = new WorktreeNameGenerator();
  const gitDiffManager = new GitDiffManager(logger);
  const gitStatusManager = new GitStatusManager(logger);
  const executionTracker = new ExecutionTracker(databaseService);
  const taskQueue = new TaskQueue();
  const runCommandManager = new RunCommandManager();
  const permissionIpcServer = new PermissionIpcServer();
  const versionChecker = new VersionChecker(configManager);
  const stravuAuthManager = new StravuAuthManager();
  const stravuNotebookService = new StravuNotebookService(logger);
  const claudeCodeManager = new ClaudeCodeManager(databaseService, logger);
  const sessionManager = new SessionManager(
    taskQueue,
    databaseService,
    executionTracker,
    worktreeManager,
    gitDiffManager,
    gitStatusManager,
    worktreeNameGenerator,
    configManager,
    logger,
    claudeCodeManager
  );

  // Initialize database
  await databaseService.initialize();

  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({ status: 'ok', mode: 'web', timestamp: new Date().toISOString() });
  });

  // API Routes
  app.get('/api/sessions', (req, res) => {
    const sessions = sessionManager.getAllSessions();
    res.json({ success: true, data: sessions });
  });

  app.post('/api/sessions', async (req, res) => {
    try {
      const session = sessionManager.createSession(
        req.body.name || 'Web Test Session',
        req.body.path || process.cwd(),
        req.body.prompt || 'Test prompt',
        req.body.worktreeTemplate,
        req.body.permissionMode || 'ignore',
        req.body.projectId,
        false,
        false,
        undefined,
        req.body.model || 'claude-sonnet-4-20250514'
      );
      res.json({ success: true, data: session });
    } catch (error: any) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  app.get('/api/projects', (req, res) => {
    const projects = databaseService.getAllProjects();
    res.json({ success: true, data: projects });
  });

  app.post('/api/projects', (req, res) => {
    try {
      const project = databaseService.createProject(
        req.body.name,
        req.body.path,
        req.body.prompt,
        req.body.runScript
      );
      res.json({ success: true, data: project });
    } catch (error: any) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  app.get('/api/config', (req, res) => {
    const config = configManager.getAll();
    res.json({ success: true, data: config });
  });

  app.post('/api/config', (req, res) => {
    try {
      Object.entries(req.body).forEach(([key, value]) => {
        configManager.set(key as any, value);
      });
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // Mock IPC endpoints for compatibility
  app.post('/api/ipc/:channel', async (req, res) => {
    const { channel } = req.params;
    const args = req.body.args || [];
    
    // Mock responses for common IPC channels
    switch (channel) {
      case 'app:get-version':
        res.json({ success: true, data: '0.2.0' });
        break;
      case 'app:get-platform':
        res.json({ success: true, data: process.platform });
        break;
      case 'projects:get-all':
        const projects = databaseService.getAllProjects();
        res.json({ success: true, data: projects });
        break;
      case 'sessions:get-all':
        const sessions = sessionManager.getAllSessions();
        res.json({ success: true, data: sessions });
        break;
      default:
        res.json({ success: false, error: `IPC channel ${channel} not implemented in web mode` });
    }
  });

  // Error handling
  app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
    console.error('Server error:', err);
    res.status(500).json({
      success: false,
      error: err.message || 'Internal server error',
    });
  });

  // Start server
  const server = app.listen(port, () => {
    console.log(`[Web Server] Crystal backend listening on port ${port}`);
    console.log(`[Web Server] Health check: http://localhost:${port}/health`);
    console.log(`[Web Server] Frontend should connect to: http://localhost:${port}`);
  });

  // Graceful shutdown
  process.on('SIGTERM', () => {
    console.log('[Web Server] SIGTERM received, shutting down gracefully...');
    server.close(() => {
      console.log('[Web Server] Server closed');
      process.exit(0);
    });
  });

  return server;
}

// Start server if run directly
if (require.main === module) {
  startWebServer().catch((err) => {
    console.error('Failed to start web server:', err);
    process.exit(1);
  });
}